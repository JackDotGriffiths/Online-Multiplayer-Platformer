<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Multiplayer Platformer</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
    <script src = "/socket.io/socket.io.js"></script>
</head>
<body>

<script type="text/javascript">
  var config = {
      type: Phaser.AUTO,
      width: 800,
      height: 600,
      physics: {
          default: 'arcade',
          arcade: {
              gravity: { y: 2000 },
              debug: false
          }
      },
      scene: {
          preload: preload,
          create: create,
          update: update
      }
  };

  var player;
  var stars;
  var obstacles;
  var platforms;
  var cursors;
  var score = 0;
  var gameOver = false;
  var scoreText;

  var map;
  var sx = 0;
  var distance = 0;
  var prevDistance = 0;
  var mapWidth = 51;
  var mapHeight = 37;

  var firstTime = true;
  //Keeps track of the index of terrain as the player joins the game, so it knows when to start generating.
  var joiningTerrainIndex = "0";
  //Used to check if a change has been made and hence new terrain should be placed
  var nextTerrainIndex = "0";
  var currentTerrainIndex = "0";

  var background;

  var game = new Phaser.Game(config);

  function preload (){
      this.load.image('sky', 'assets/sky.png');
      this.load.image('ground', 'assets/platform.png');
      this.load.image('star', 'assets/star.png');
      this.load.image('obstacle', 'assets/obstacle.png');
      this.load.spritesheet('dude', 'assets/dude.png', { frameWidth: 32, frameHeight: 48 });
  }

  function create (){
      var self = this;
      this.socket = io();
      this.socket.on('currentPlayers',function(players){
        Object.keys(players).forEach(function(id){
          if(players[id].playerId == self.socket.id){
            console.log("Player Match Found. Socket ID is " + players[id].playerId + " . Name assigned of " + players[id].playerName);
          }
        })
      })

      var background = this.physics.add.sprite(400, 300, 'sky');
      background.body.velocity.x=240;
      background.body.setAllowGravity(false);
      platforms = this.physics.add.staticGroup();
      stars = this.physics.add.staticGroup();
      obstacles = this.physics.add.staticGroup();

      player = this.physics.add.sprite(300,400,'dude');
      //  Our player animations, turning, walking left and walking right.
      this.anims.create({
          key: 'left',
          frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }),
          frameRate: 10,
          repeat: -1
      });

      this.anims.create({
          key: 'turn',
          frames: [ { key: 'dude', frame: 4 } ],
          frameRate: 20
      });

      this.anims.create({
          key: 'right',
          frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),
          frameRate: 10,
          repeat: -1
      });

      //  Input Events
      cursors = this.input.keyboard.createCursorKeys();

      //  The score
      scoreText = this.add.text(16, 16, 'score: 0', { fontSize: '32px', fill: '#000' });

      //  Collide the player and the stars with the platforms
      this.physics.add.collider(player, platforms);
      this.physics.add.collider(stars, platforms);
      this.physics.add.collider(obstacles, platforms);

      //  Checks to see if the player overlaps with any of the stars, if he does call the collectStar function
      this.physics.add.overlap(player, stars, collectStar, null, this);

      this.physics.add.collider(player, obstacles, hitObstacle, null, this);

      $.get('/data', {}, function(data){
        console.log(data.toString());
        joiningTerrainIndex = data.toString();
        currentTerrainIndex = joiningTerrainIndex;
        nextTerrainIndex = joiningTerrainIndex;
      });

  }

  function update (time, delta){
      if (gameOver){return;}

      player.setVelocityX(240);
      player.anims.play('right', true);

      if (cursors.up.isDown && player.body.touching.down)
      {
          player.setVelocityY(-900);
      }

      //  Any speed as long as 16 evenly divides by it
      sx += 4;
      distance += sx;


      this.cameras.main.scrollX = sx;
      scoreText.x = sx+16;
      //Get the next terrain index from the server
      $.get('/data', {}, function(data){
        nextTerrainIndex = data.toString();
        if(currentTerrainIndex != nextTerrainIndex)
        {
          console.log("Generating Panel " + currentTerrainIndex);
          //console.log("Changed from section " + currentTerrainIndex + " to section " + nextTerrainIndex);
          currentTerrainIndex = nextTerrainIndex;
          switch(currentTerrainIndex)
          {
            case "1":
              spawnBlock1();
              break;
            case "2":
              spawnBlock2();
              break;
            case "3":
              spawnBlock3();
              break;
            case "4":
              spawnBlock4();
              break;
            case "5":
              spawnBlock5();
              break;
          }
        }
      });


      if (nextTerrainIndex == joiningTerrainIndex && firstTime)
      {
        platforms.create(sx+300, 568, 'ground');
      }
      else{
        firstTime = false;
      }


  }
  //Procedural Generation Methods
  function spawnBlock1(){
    var offset = sx+400;
    platforms.create(offset+ 400,500, 'ground');
    platforms.create(offset+800,400, 'ground');
    platforms.create(offset+1200,500, 'ground');
    stars.create(offset+470,470,'star');
    stars.create(offset+700,370,'star');
    stars.create(offset+1250,470,'star');
    obstacles.create(offset+350,465,'obstacle');
    obstacles.create(offset+760,365,'obstacle');
  }
  function spawnBlock2(){
    var offset = sx+400;
    platforms.create(offset+ 400,500, 'ground');
    platforms.create(offset+800,400, 'ground');
    platforms.create(offset+1200,300, 'ground');
    stars.create(offset+430,470,'star');
    stars.create(offset+830,270,'star');
    stars.create(offset+1250,270,'star');
    obstacles.create(offset+500,465,'obstacle');
    obstacles.create(offset+1100,265,'obstacle');
  }
  function spawnBlock3(){
    var offset = sx+400;
    platforms.create(offset+ 400,550, 'ground');
    platforms.create(offset+800,450, 'ground');
    platforms.create(offset+1200,350, 'ground');
    stars.create(offset+430,520,'star');
    stars.create(offset+830,420,'star');
    obstacles.create(offset+480,515,'obstacle');
    obstacles.create(offset+790,415,'obstacle');
  }
  function spawnBlock4(){
    var offset = sx+400;
    platforms.create(offset+ 400,550, 'ground');
    platforms.create(offset+1010,500, 'ground');
    platforms.create(offset+920,500, 'ground');
    stars.create(offset+820,470,'star');
    obstacles.create(offset+960,465,'obstacle');
    obstacles.create(offset+880,465,'obstacle');
    obstacles.create(offset+445,515,'obstacle');
  } //Place Obstacles here
  function spawnBlock5(){
    var offset = sx+400;
    platforms.create(offset+ 400,570, 'ground');
    platforms.create(offset+800,450, 'ground');
    platforms.create(offset+1200,450, 'ground');
    obstacles.create(offset+880,415,'obstacle');
    obstacles.create(offset+1100,415,'obstacle');
    obstacles.create(offset+1300,415,'obstacle');
    stars.create(offset+830,420,'star');
  } //Place Obstacles Here & Ensure Score moves with camera


  //Collection/Interaction Methods
  function collectStar (player, star){
      star.disableBody(true, true);

      //  Add and update the score
      score += 10;
      scoreText.setText('score: ' + score);

      if (stars.countActive(true) === 0)
      {
          //  A new batch of stars to collect
          stars.children.iterate(function (child) {

              child.enableBody(true, child.x, 0, true, true);

          });

      }
  }
  function hitObstacle(player, obstacle){
      die(player);
  }

 //Player Controller
  function die(player){
    //player.physics.pause();
    player.setVelocityX(2);
    player.setTint(0xff0000);
    player.anims.play('turn');
    gameOver = true;
  }

</script>

</body>
</html>
